--- id: documentation title: DocumentaÃ§Ã£o â€” PW2 Shop --- # ðŸ›’ Lojinha â€” DocumentaÃ§Ã£o Oficial Este documento explica **como executar a aplicaÃ§Ã£o completa** (backend + frontend + PostgreSQL via Docker) e descreve de forma clara o **fluxo de cadastro de produtos**, incluindo o que acontece em cada camada (**controller â†’ useCase â†’ repository â†’ banco**). --- # ðŸš€ Como rodar a aplicaÃ§Ã£o A aplicaÃ§Ã£o Ã© dividida em trÃªs partes: - **Backend** â€” Node.js + Express + Drizzle ORM - **Frontend** â€” Next.js 16 - **Banco de Dados** â€” PostgreSQL via Docker Toda a stack sobe com **um Ãºnico comando Docker Compose**. --- # ðŸ“¦ 1. Clonar o projeto
bash
git clone https://github.com/seu-repo/pw2.git
cd pw2

ðŸ³ 2. Subir banco + backend + frontend
sudo docker compose up -d --build

Este comando:

Cria o PostgreSQL

ConstrÃ³i e inicia o backend

ConstrÃ³i e inicia o frontend

Acesse:

Frontend: http://localhost:3000

Backend: http://localhost:3333

DB: localhost:5432

ðŸ§± Arquitetura â€” Fluxo de Produto

Fluxo da criaÃ§Ã£o de produto:

Frontend â†’ Controller â†’ UseCase â†’ Repository â†’ Banco

ðŸŸ¦ FLUXO COMPLETO â€” Criar Produto

A seguir, vocÃª verÃ¡ como funciona o fluxo inteiro de criaÃ§Ã£o de produto, desde o formulÃ¡rio atÃ© o banco.

1ï¸âƒ£ FRONTEND (Next.js)

O formulÃ¡rio de criaÃ§Ã£o envia:

const payload = {
nome: data.nome,
descricao: data.descricao,
preco: data.preco,
estoque: data.estoque,
categoriaId: data.categoriaId
};

api.createProduct(payload);

Chamando:

POST /products
Content-Type: application/json

2ï¸âƒ£ CONTROLLER

Arquivo: CreateProductController.ts

Recebe a requisiÃ§Ã£o, valida e aciona o caso de uso.

export class CreateProductController {
  async handle(req, res) {
    const { nome, descricao, preco, estoque, categoriaId } = req.body;

    const createProduct = new CreateProductUseCase(productsRepository);

    await createProduct.execute({
      nome,
      descricao,
      preco,
      estoque,
      categoriaId
    });

    return res.status(201).json({ message: "Produto criado com sucesso" });

}
}

3ï¸âƒ£ USE CASE (Regra de NegÃ³cio)

Arquivo: CreateProductUseCase.ts

O useCase garante:

Nome nÃ£o duplicado

Categoria existe

Dados corretos para envio ao repositÃ³rio

export class CreateProductUseCase {
  constructor(private productsRepository) {}

async execute(payload) {
const existing = await this.productsRepository.findByName(payload.nome);
if (existing) {
throw new Error("Produto jÃ¡ cadastrado");
}

    await this.productsRepository.create({
      nome: payload.nome,
      descricao: payload.descricao,
      preco: payload.preco,
      estoque: payload.estoque,
      categoriaId: payload.categoriaId,
      isDeleted: false
    });

}
}

4ï¸âƒ£ REPOSITORY (Acesso ao Banco)

Arquivo: ProductsRepository.ts

Onde ocorre de fato:

ConversÃ£o

InserÃ§Ã£o

Query Drizzle ORM

async create(data) {
await db.insert(productsTable).values({
nome: data.nome,
descricao: data.descricao,
preco: data.preco,
estoque: data.estoque,
categoriaId: data.categoriaId,
isDeleted: false
});
}

5ï¸âƒ£ BANCO DE DADOS

Query SQL equivalente:

INSERT INTO "Product"
("nome", "descricao", "preco", "estoque", "categoriaId", "is_deleted")
VALUES ($1, $2, $3, $4, $5, false);

ðŸ”„ Diagrama do Fluxo
sequenceDiagram
participant FE as Frontend
participant CT as Controller
participant UC as UseCase
participant RP as Repository
participant DB as Database

    FE->>CT: POST /products
    CT->>UC: execute(payload)
    UC->>RP: create(data)
    RP->>DB: INSERT INTO Product...
    DB-->>RP: OK
    RP-->>UC: OK
    UC-->>CT: OK
    CT-->>FE: 201 Created

ðŸ§ª Testando no Insomnia / Postman
POST http://localhost:3333/products

Body:

{
"nome": "Monitor LG",
"descricao": "24 polegadas",
"preco": "799.90",
"estoque": 15,
"categoriaId": "UUID-DA-CATEGORIA"
}

Resposta:

{
"message": "Produto criado com sucesso"
}
